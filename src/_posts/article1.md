# Twelve-Factor App勉強会

[The Twelve-Factor App](https://12factor.net/)

[AWS](https://aws.amazon.com/jp/blogs/compute/applying-the-twelve-factor-app-methodology-to-serverless-applications/)にも[GCP](https://cloud.google.com/solutions/twelve-factor-app-development-on-gcp?hl=ja_JP)にも，Twelve-Factor Appの具体的な適用先のサービスが紹介されている．

[こちら](https://pythonhosted.org/fapistrano/12factor.html)に日本語かつ具体的なコード付きの例が載っている．





## I. コードベース (Codebase)

*One codebase tracked in revision control, many deploys*

サーバーで動くアプリとコードベースは常に１対１に対応しているべきで，複数のコードベースをまとめて1つのアプリにしたり，1つのコードベースで複数のアプリを管理してはいけない，という原則．

コードベースというのはGitとかSubversionのリポジトリだと思えばよい．

この原則がある理由は，複数のリポジトリから1つのアプリケーションが作られたりするとビルドやデプロイの手順が複雑化してオペミスを引き起こしたりするから．要するに管理が面倒．


- 複数のコードベースから１つのアプリケーションを作ろうとしている場合，それは**アプリケーションではなく分散システムと呼ぶべき**です．分散システムのそれぞれのコンポーネントがアプリケーションであり，個別にTwelve-Factorを適用するべきです．

- もし，同じコードを共有する複数のアプリケーションがあるなら，共通コードを別々に管理するのは超面倒なので，共通のコードを（１つまたは複数の）ライブラリに分解して，そのライブラリを依存関係管理ツールで組み込むようにすればOK．（pythonのpipとか，rubyのgemとかだと理想的？）

- アプリケーションごとにただ1つのコードベースが存在しますが，アプリケーションのデプロイ方法は複数存在してもOKです．例えば，ローカル環境でテストするためのデプロイと，本番用のクラウド環境へのデプロイは異なっていてもOKです．


## II. 依存関係 (Dependencies)

*Explicitly declare and isolate dependencies*

全ての依存関係は専用のファイルなりドキュメントで完全かつ厳密に書かれるべきであり、システム全体に入っている暗黙的なパッケージの存在を前提にしてはいけない，という原則．

例えば，pythonだと`sys`とか`os`といった標準モジュールはpythonをインストールした時点で入っていることが多いけど，そういったものを暗黙的に使っておいて，依存関係を表すファイル（例えばrequirement.txt）に書かない状況があってはならない．全部`pip freeze`でrequirements.txtに書き出すこと．

linuxでも`curl`とか`wget`など，本当はインストールの必要があるけど「忘れてたテヘッ(*´∀`*)」みたいなことがあってはならない．

さらに実行時には依存関係分離ツールを使ってあげるとなお良し．Dockerとか，pythonのvirtualenvで環境が分離できる．









## III. 設定 (Config)
*Store config in the environment*

いくつかの設定値：

- デプロイごとに変えないといけないような，接続先のDB名や，URL
- AWSやTwitterなど，外部サービスの認証情報（ユーザー名とかパスワードとかその他のkeyとか）
- デプロイ毎に変化させないといけない値

は決してリポジトリ内のファイルとかコードに入れるな．環境変数を使え，という原則．

理由は，コードに含めてしまうと環境ごとにコードを書き換えてビルドするのが必要になり、設定ファイルの場合は環境ごとにファイルが必要となりスケールしにくくなるから．

ただ，プロダクトの挙動をあとで変更したりするための設定値（config/settings.ymlに，何分ごとに外部APIを叩くか，みたいな設定値とか）はファイルに含めてもOK．

この原則のベストプラクティスは，CDパイプラインを介して各環境別にアプリケーションをデプロイすること．

環境変数に入れる以外の方法として、`config/database.yml`のようにリポジトリ外のファイルに書き出しておくという方法もあるけど，あまり良くないらしい．（私はこれで困ったことないけど…）

だいたい認証情報とか機密情報がコードベースに書かれているのはセキュリティ的にヤバすぎる．





## IV. バックエンドサービス (Backing Services)
*Treat backing services as attached resources*


DB、SMTPサーバー、Amazon S3、Twitter API、Google MapsAPIなどの外部サービスはアタッチ/デタッチ可能なリソースとして捉え、コードを修正しなくても変更できるように環境変数に設定値(URLやユーザ情報等)を定義しましょう，という原則．

外部サービスの変更に伴ってコード修正が必要になると，ビルド方法がややこしいからです．

また仮にDBが落ちた場合に、環境変数を書き換えるだけで別のDBに接続でき、障害対応が可能になるから．

## V. ビルド、リリース、ラン（Build, release, run）
*Strictly separate build and run stages*

サーバー（ローカル以外）ではビルド、リリース、ランのフェーズを明確に分けること．

![release.png](https://qiita-image-store.s3.amazonaws.com/0/6664/58169343-6baa-c2f0-15d2-60b8dcb4668e.png "release.png")

- ビルド：コードレポジトリを実行可能な形式にすること。サードパーティーのコードをフェッチして依存解決し、バイナリとアセットをコンパイルする。
- リリース：ビルドステージでできたビルドと、そのデプロイに関する設定を統合し、各サーバマシン上ですぐに実行できる状態にすること。
- ラン：実際にサーバーの実行環境でアプリを起動すること。これはプロセスのまとまりをそのリリースの状態で立ち上げることで実現される。

実行中のソースに手を加えたりするとオペミスによる障害につながるため、テスト済みのコードをビルドし、その結果(ビルド)を各環境にリリースして実行するようにしましょう．

## VI. プロセス (Processes)
*Execute the app as one or more stateless processes*

プロセスはステートレスなものとし、サーバ内のインスタンスやファイルでステータスを持つことは避けるようにしましょう。

なぜならインスタンスは仮想サーバのスケールアウト/スケールインによって増減するものであり永続的に存在するものではないためです。

永続的なステータスを持ちたい場合はDB等を使用しましょう。

面倒だからといって一時的な情報をインスタンス内のファイルとかで管理していると，障害が起きた時に参照できなくなったりします．


## VII. ポートバインディング (Port binding)
*Export services via port binding*
(c.f. herokuのweb dyno, [heroku/rails_serve_static_assets gem](https://github.com/heroku/rails_serve_static_assets)のREADME)

アプリケーション内にサーバを組み込み、サーバ単位ではなくポート単位でサービス公開できるようにしましょう．

この時、HTTPポートを公開し、そこに来たリクエストを処理する方式を採用すると良い。こうすると、開発環境では、`http://localhost:3000/`などでアクセスできるし、本番環境ではルーティングレイヤがうまく公開されているポートとコンテナのポートをバインドすればよい(例えば80番のアクセスをコンテナの3000番につなげる)。

Webサーバーライブラリの例として、PythonにおけるTornado、RubyにおけるThin、Javaやその他のJVMベースの言語におけるJettyなどを使えばOK．

ここで注目すべきは、ポートバインディングの方法によって、あるアプリケーションが他のアプリケーションにとってのバックエンドサービスになれる点である．

## VIII. 並行性 (Concurrency)
*Scale out via the process model*

スレッドではなく、プロセスを用いてスケールアウトする。

スレッドだとメモリを共有する上、何がどのくらい動いているのかが把握しづらい。
これに対し、プロセスは何も共有しないし、どのタイプのプロセスがどのくらい動いているかを見ることで、メモリやCPUの資源をうまく分配する設計もしやすくなる。

![process-types.png](https://qiita-image-store.s3.amazonaws.com/0/6664/1406c62d-e30d-e52a-067f-3358b9b225b5.png "process-types.png")

もちろん、各プロセスが、その中でスレッドを用いて多重化をするのはOK。言っているのは、複数台でのスケールアウトを考える時に、プロセスを1つの単位とした構成にしないと難しいよいうこと。

なお、プロセスの管理（アウトプットストリーム、プロセスのクラッシュ、リスタートなどの管理）は、OSレベルのプロセス管理システムに任せるべき．



## IX. 廃棄容易性 (Disposability)
*Maximize robustness with fast startup and graceful shutdown*

それぞれのプロセスは、秒単位でパッと立ち上げられて、パッと捨てられる構成にしなければならない。

特にプロセスのスタートに要する時間は大切で、これが速いとスケールアップがあるプロセスを別のマシンに移動する事が容易になる。

`SIGTERM`を受け取ってプロセスは終了する時は、新しいリクエストを受け付けるのをやめ、現在行っている処理は完了して、お行儀よく終了する必要がある。

これを実現するには、Webのリクエストは数秒で終わるような設計、ずっとポーリングしているようなリクエストがある場合、クライアント側で接続が失われたらユーザーに気付かれないように再接続要求をするように設計する必要がある。

Workerの場合は、Jobの処理はQueueシステムを用い、Lockする仕組みの場合はLockを返して死ぬようにする。各JobはTransactionなどで囲い、何度失敗しても問題がないようにしたり、冪等性のある設計にしたりしなければならない。
本来は、`SIGTERM`ではない、ハードウェア障害などに起因する突然の終了にも頑健でなければならない。クライアントの接続が切れたらJobをQueueに戻すといったBeanstalkdのようなバックエンドを使うことが推奨される。


## X. 開発/本番一致 (Dev/prod parity)
*Keep development, staging, and production as similar as possible*

開発環境と、production, stagingなどといったサーバー環境を出来る限り同じ環境にしよう。

昔は

- 時間：書いたコードが何日か経ってから製品版になる
- 人：開発する人とサーバーにデプロイする人は違う
- ツール：開発環境はSQLiteとMac、サーバーはMySQLとLinuxなどと異なる

といったことが普通だったが

今は

- 時間：数分から数時間で書いたコードが本番にデプロイされる
- 人：開発する人とデプロイする人が同じ
- ツール：ローカルとサーバーでほぼ同じ

となっているのが良い。

これは、homebrew、Chef/Puppet、Vagrantなどのツールの進化によって可能になった。なので、安心して継続的デプロイするために、開発用のローカル環境と本番用のサーバー環境はできるだけ一緒にしよう。


## XI. ログ (Logs)
*Treat logs as event streams*
(c.f. `heroku logs -t`, [logging用add-on](https://addons.heroku.com/#logging)の使い方)

ログはファイル書き出しなどではなくイベントストリームとして扱う。

要するに、アプリは`stdout`にログを吐き出すだけでよく、ログの保存先やルーティングは考えなくて良い。

こうするとローカルの開発環境ではログはターミナル上で見えるし、サーバー上ではLogplexやFluentdなどの別の独立したサービスがアウトプットストリームを管理する。これらのルーターは最終的にFileにログをストアしてもいいし、リアルタイムにターミナルにtailとして送り出しても良い。更にはログを検索できるようなサービスに送ることも可能になる。

## XII. 管理プロセス (Admin processes)
*Run admin/management tasks as one-off processes*
(c.f. `heroku run`)

管理やメンテナンス等の作業は一度だけ実行されるプロセスとして扱うべきである。具体例としては、`rails c`や`rails r`、`rake db:migrate`などが挙げられる。

この時、一時的な管理プロセスを`rails s`などの長く走っているプロセスと同じ環境で走らせてあげるのが大切。このために、Admin用のスクリプトなども同じコードベースに入れ、同期の問題が発生しない様にする。





# 事例

- MaaS